(** This module is a helper for interfaces of a particular shape. * * The idea
    is that updates are generated by a component when another * component should
    be notified of events. For example, when a VM changes * state, xenopsd uses
    this interface so that xapi knows something has * changed. The updates
    contain no information other than that something * has changed, so
    additionally the interface needs to have some sort of * mechanism for
    querying the current state of the object in question. * * This module
    provides functions for adding updates, adding barriers * (which contain a
    snapshot of the current updates), and a blocking call to * that returns the
    latest set of updates, optionally given a token that * represents the last
    set of updates received. *)

module type INTERFACE = sig
  val service_name : string

  module Dynamic : sig
    type id

    val rpc_of_id : id -> Rpc.t
  end
end

module Updates : functor (Interface : INTERFACE) -> sig
  type id = int

  (* Updates are kept in a `t` *)
  type t

  (* Create an empty updates recorder using the given scheduler *)
  val empty : Scheduler.t -> t

  (* last_id [dbg] [t] returns the last id that's in use in [t] *)
  val last_id : string -> t -> int

  (* The return type for `get`. Returns a list of barriers, then a list of
     updates, then a token to pass to the next invocation of `get` *)
  type get_result =
    (int * Interface.Dynamic.id list) list * Interface.Dynamic.id list * id

  (* [get dbg ?with_cancel from timeout t] is a blocking call that will return
     all the updates recorded in [t] since [from] (or for all time if [from] is
     None). [timeout], if it is not None, is the timeout in seconds to wait.
     [dbg] is a debug string. [with_cancel] is a function passed in that allows
     this call to be cancelled. See Task_server.with_cancel for an example
     function that may be used *)
  val get :
       string
    -> ?with_cancel:((unit -> unit) -> (unit -> get_result) -> get_result)
    -> id option
    -> int option
    -> t
    -> get_result

  (* Add an update to a particular type of item (e.g. 'VM' or 'VBD', defined in
     INTERFACE) *)
  val add : Interface.Dynamic.id -> t -> unit

  (* Remove an update *)
  val remove : Interface.Dynamic.id -> t -> unit

  (* Filter updates to remove those that don't satisfy the predicate passed in *)
  val filter : (Interface.Dynamic.id -> bool) -> t -> unit

  (* [inject_barrier n p t] Inject a barrier identified by [n] into [t]. The
     barrier will contain a snapshot of all current updates that match the
     predicate [p]. *)
  val inject_barrier : int -> (Interface.Dynamic.id -> int -> bool) -> t -> unit

  (* Removes a barrier *)
  val remove_barrier : int -> t -> unit

  (* The Dump module is to dump the internal state of the Updates value for
     debugging purposes *)
  module Dump : sig
    type u = {id: int; v: string}

    type dump = {updates: u list; barriers: (int * int * u list) list}

    val rpc_of_dump : dump -> Rpc.t

    val dump_of_rpc : Rpc.t -> dump

    val make : t -> dump
  end
end
